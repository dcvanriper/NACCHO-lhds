# naccho_configuration.R
# 
# This script is where NACCHO staff members can make modifications to XXX in
# one place. Then they can re-run the scripts to create:
# 
# 1. urban/rural LHD counts
# 2. ACS totals
# 3. ACS estimates from IPF 

## ---- Load required packages ----
require(glue)

## ---- !!!USER PROVIDED VALUES!!! ----
## These two variables must be set by the person running the script, IF something has changed since the last time the script was run.

## SET THE LHD VINTAGE
## We use this on our output file names to help NACCHO staff determine the LHD vintage for the estimates
lhd_vintage <- "lhd2022"

## SET THE ACS DATASET 
## The ACS_dataset is the 5-year ACS dataset from which you want to generate LHD totals. To update this variable
## to a new 5-year dataset, you just need to the change the two years in the string (e.g., change 2017 to 2018 and 2021 to 2022).

## New ACS datasets will have a similar name to the one included below. E.g.:
## 2018_2022_ACS5a
## 2019_2023_ACS5a
## 2020_2024_ACS5a
acs_dataset <- "2017_2021_ACS5a"

## SET THE DATA DIRECTORY PATH
## This is the path to the main directory that contains all required data files.
user <- "knowlesk" # This should be edited if a new person runs the script
dat_dir <- glue("/Users/{user}/Box Sync/NACCHO GIS/lhd-updates/data") 

## ---- !!!YOU SHOULD NOT NEED TO EDIT BELOW INFORMATION!!! ---- 

## ---- Set scientific notations to off ----
options(scipen = 999)

## ---- Constants ----

## List of state abbreviations. We add DC to the vector and remove Rhode Island because RI has
## no LHDs.
state_abbr <- c(state.abb, "DC")
state_abbr <- setdiff(state_abbr, "RI")

## Output data directory path for ACS and urban/rural estimates. These are the paths where output files are written.
acs_output_dir <- glue("{dat_dir}/output-data/{acs_dataset}")
ur_output_dir <- glue("{dat_dir}/output-data/urban_rural")

## Create the ACS output data directory if it doesn't already exist
if(!dir.exists(acs_output_dir)){
  dir.create(acs_output_dir, recursive= TRUE)
}

## Create the urban/rural output data directory if it doesn't already exist
if(!dir.exists(ur_output_dir)){
  dir.create(ur_output_dir, recursive= TRUE)
}

## ---- Constants for urban/rural processing ----

## Paths to the geocorr crosswalks - these crosswalks provide us with the urban/rural designation for each 2020 census block
file_geocorr1 <- glue(dat_dir, "/tables/geocorr/geocorr2022_2310905557_HI.csv.gz")
file_geocorr2 <- glue(dat_dir, "/tables/geocorr/geocorr2022_2310909397_MS.csv.gz")
file_geocorr3 <- glue(dat_dir, "/tables/geocorr/geocorr2022_2310908189_PA.csv.gz")
file_geocorr4 <- glue(dat_dir, "/tables/geocorr/geocorr2022_2310901017_WY.csv.gz")

## Path to the 2020 census block that provides the total population for each block
## Since we use this with the geocorr data, I think it would be best to move the gzip file
## to that directory. 
file_blkpop20 <- glue(dat_dir, "/tables/geocorr/nhgis1726_ds248_2020_block.csv.gz")

## ---- Constants for ACS totals ----
## These constants are used to generate the ACS totals from the tables that contains Place070 data.

# The ACS provides Place070 data for four tables - Total Population, Race, Housing Units, Housing Tenure
place070_data_tables <- c("B01003", "B02001", "B25001", "B25003")

# ACS download directory - this directory will hold the ACS data file containing the Total Population, Race, Housing Units, and Housing Tenure info
download_acs_totals_dir <- glue(dat_dir, "/tables/nhgis-csv/{acs_dataset}/acs_totals")

## ---- Constants for the ACS estimates generated by Iterative Proportional Fitting ----
## Sex by Age
# ACS table
acs_sexage <- "B01001"

# Download directory
download_acs_sexage_dir <- glue(dat_dir, "/tables/nhgis-csv/{acs_dataset}/sexage")

## Household Income
# ACS table
acs_hhincome <- "B19001"

# Download directory
download_acs_hhincome_dir <- glue(dat_dir, "/tables/nhgis-csv/{acs_dataset}/hhincome")

## Owner-Occupied Housing Value
# ACS table
acs_ownoccvalue <- "B25075"

# Download directory
download_acs_ownoccvalue_dir <- glue(dat_dir, "/tables/nhgis-csv/{acs_dataset}/ownoccvalue")

## Renter-Occupied Gross Rent
# ACS table
acs_grossrent <- "B25063"

# Download directory
download_acs_grossrent_dir <- glue(dat_dir, "/tables/nhgis-csv/{acs_dataset}/grossrent")

## ---- !!!DO NOT EDIT BELOW!!! ---- 

## ---- Source R code to create require IPF functions ----
# Iterative proportional fitting code used in all ipf scripts -- DO NOT EDIT
ipf2 <- function(rowcontrol, colcontrol, seed, maxiter=50, closure=0.0001, debugger=FALSE){
  # input data checks: 
  if(debugger)print("checking inputs")
  #sum of marginal totals equal and no zeros in marginal totals
  if(debugger){print("checking rowsum=colsum")}
  if(sum(rowcontrol) != sum(colcontrol)) 
    stop("sum of rowcontrol must equal sum of colcontrol")
  if(debugger){print("checking rowsums for zeros")}
  if(any(rowcontrol==0)){
    numzero <- sum(rowcontrol==0)
    rowcontrol[rowcontrol==0] <- 0.001
    warning(paste(numzero, "zeros in rowcontrol argument replaced with 0.001", sep=" "))
  }
  if(debugger){print("Checking colsums for zeros")}
  if(any(colcontrol==0)){
    numzero <- sum(colcontrol==0)
    colcontrol[colcontrol==0] <- 0.001
    warning(paste(numzero, "zeros in colcontrol argument replaced with 0.001", sep=" "))
  }
  if(debugger){print("Checking seed for zeros")}
  if(any(seed==0)){
    numzero <- sum(seed==0)
    seed[seed==0] <- 0.001
    warning(paste(numzero, "zeros in seed argument replaced with 0.001", sep=" "))
  }
  # set initial values
  result <- seed
  rowcheck <- 1
  colcheck <- 1
  checksum <- 1
  iter <- 0
  # successively proportion rows and columns until closure or iteration criteria are met
  ##########
  if(debugger){print(checksum > closure);print(iter < maxiter)}
  while((checksum > closure) && (iter < maxiter))
  {
    #########
    if(debugger){print(paste("(re)starting the while loop, iteration=",iter)) }
    
    coltotal <- colSums(result)
    colfactor <- colcontrol/coltotal
    result <- sweep(result, 2, colfactor, "*")
    if(debugger){
      print(paste("column factor = ",colfactor))
      print(result)}
    
    rowtotal <- rowSums(result)
    rowfactor <- rowcontrol/rowtotal
    result <- sweep(result, 1, rowfactor, "*")
    if(debugger){
      print(paste("row factor = ",rowfactor))
      print(result)}
    
    rowcheck <- sum(abs(1-rowfactor))
    colcheck <- sum(abs(1-colfactor))
    checksum <- max(rowcheck,colcheck)
    iter <- iter + 1
    #print(paste("Ending while loop, checksum > closure",checksum > closure,"iter < maxiter",iter < maxiter))
  }#End while loop
  
  result <- list(fitted.table=result, number.iterations=iter, tolerance=checksum)
  result
}
